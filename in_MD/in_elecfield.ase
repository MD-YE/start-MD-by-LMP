import ase.io
import numpy as np
from ase.md.verlet import VelocityVerlet
from ase import units
from ase.md.velocitydistribution import MaxwellBoltzmannDistribution
from nequip.ase import NequIPCalculator

# -------------------------
atoms = ase.io.read("merged.pdb")
calc = NequIPCalculator.from_deployed_model("LiOHmtd.pth", extra_outputs=["charges"]) # Nequip-charge MLP 
atoms.info.setdefault("total_charge", 0.0)  
atoms.calc = calc


temperature = 300  # K
MaxwellBoltzmannDistribution(atoms, temperature_K=temperature)
Efield = np.array([0.0, 0.0, 0.1])
OUTPUT_XYZ = "traj_extxyz.xyz"

# -------------------------
# Class MD elecforce
class MDWithE(VelocityVerlet):
    def __init__(self, atoms, timestep, efield, output_xyz=None, **kwargs):
        super().__init__(atoms, timestep, **kwargs)
        self.efield = np.array(efield)
        self.output_xyz = output_xyz

    def step(self):
        forces = self.atoms.get_forces()
        charges = self.atoms.calc.results.get("charges", None) # atoms.arrays['initial_charges'], atoms.calc.results['charges']
        if charges is None:
            raise RuntimeError("Charges not found; make sure extra_outputs=['charges']")

        # add charge force
        forces_with_field = forces + charges[:, None] * self.efield
        orig_forces = self.atoms.arrays.get("forces", None)
        self.atoms.arrays["forces_temp"] = forces_with_field
        # backup_force
        self._forces_backup = self.atoms.get_forces
        self.atoms.get_forces = lambda: self.atoms.arrays["forces_temp"]

        super().step()

        # get_oriforce
        self.atoms.get_forces = self._forces_backup
        if orig_forces is None:
            del self.atoms.arrays["forces_temp"]
        else:
            self.atoms.arrays["forces_temp"] = orig_forces

        # output extxyz
        if self.output_xyz:
            ase.io.write(
                self.output_xyz,
                self.atoms,
                format="extxyz",
                columns=["symbols", "positions", "forces", "charges"],
                append=True
            )

# -------------------------
dyn = MDWithE(atoms, timestep=1.0 * units.fs, efield=Efield, output_xyz=OUTPUT_XYZ)

# -------------------------
# run MD
n_steps = 100
for step in range(n_steps):
    dyn.run(1)
    epot = atoms.get_potential_energy()
    charges = atoms.calc.results.get("charges", None)
    print(f"Step {step:5d}  E_pot = {epot:12.6f} eV   q[0..3]={charges[:4]}")

